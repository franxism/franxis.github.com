#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Z80.h"
#include "machine.h"
#include "memmap.h"
#include "roms.h"
#include "osdepend.h"
#include "sndhrdw.h"


#define SND_CLOCK 3072000	/* 3.072 Mhz */


unsigned char samples[8][32] =
{
	{ 0xff,0x11,0x22,0x33,0x44,0x55,0x55,0x66,0x66,0x66,0x55,0x55,0x44,0x33,0x22,0x11,
	0xff,0xdd,0xcc,0xbb,0xaa,0x99,0x99,0x88,0x88,0x88,0x99,0x99,0xaa,0xbb,0xcc,0xdd },
	{ 0xff,0x44,0x66,0x66,0x55,0x33,0x11,0x22,0x33,0x33,0x22,0x11,0xee,0xcc,0xbb,0xdd,
	0xff,0x11,0x33,0x22,0x00,0xdd,0xcc,0xbb,0xbb,0xcc,0xdd,0xbb,0x99,0x88,0x88,0xaa },
	{ 0xff,0x22,0x44,0x55,0x66,0x55,0x44,0x22,0xff,0xcc,0xaa,0x99,0x88,0x99,0xaa,0xcc,
	0xff,0x33,0x55,0x66,0x55,0x33,0xff,0xbb,0x99,0x88,0x99,0xbb,0xff,0x66,0xff,0x88 },
	{ 0xff,0x55,0x33,0x00,0x33,0x55,0x11,0xee,0x33,0x66,0x44,0xff,0x11,0x22,0xee,0xaa,
	0xff,0x44,0x00,0xcc,0xdd,0xff,0xaa,0x88,0xbb,0x00,0xdd,0x99,0xbb,0xee,0xbb,0x99 },
	{ 0x88,0x00,0x77,0xff,0x99,0x00,0x66,0xff,0xaa,0x00,0x55,0xff,0xbb,0x00,0x44,0xff,
	0xcc,0x00,0x33,0xff,0xdd,0x00,0x22,0xff,0xee,0x00,0x11,0xff,0xff,0x00,0x00,0xff },
	{ 0xff,0x00,0xee,0x11,0xdd,0x22,0xcc,0x33,0xbb,0x44,0xaa,0x55,0x99,0x66,0x88,0x77,
	0x88,0x77,0x99,0x66,0xaa,0x55,0xbb,0x44,0xcc,0x33,0xdd,0x22,0xee,0x11,0xff,0x00 },
	{ 0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,
	0x77,0x66,0x55,0x44,0x33,0x22,0x11,0x00,0xff,0xee,0xdd,0xcc,0xbb,0xaa,0x99,0x88 },
	{ 0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,
	0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77 }
};


/***************************************************************************

  Initialize the sound hardware. Returns 0 if successful.

***************************************************************************/
int sh_init(const char *gamename)
{
	return 0;
}



int sh_start(void)
{
	return 0;
}



void sh_stop(void)
{
}



/***************************************************************************

  Handle a write to memory.
  This function is called when the emulated code writes to RAM.

  Arguments:
  dword A - Memory address to write to.
  byte V - Value to write into memory.

  If the address given concerns the sound hardware, the write is performed
  (together with additional operations which might be required by the sound
  hardware) and the function returns non zero. Otherwise, it returns 0.

***************************************************************************/
int soundchanged;

int sh_wrmem(dword A,byte V)
{
	if (A >= SOUND_BASE && A < SOUND_BASE + 0x20)
	{
		if (RAM[A] != (V & 0x0f))
			soundchanged = 1;
		RAM[A] = V & 0x0f;
		return 1;
	}
	else return 0;
}



/***************************************************************************

  Execute an OUT instruction.

  If the port given concerns the sound hardware, the sound hardware processes
  it and the function returns non zero. Otherwise, it returns 0.

***************************************************************************/
int sh_doout(byte A,byte V)
{
	return 0;
}



/***************************************************************************

  Read a data port IN.

***************************************************************************/
int sh_doin(byte A,byte *V)
{
	return 0;
}



void sh_update(void)
{
	if (play_sound == 0) return;

	if (RAM[SOUND_ENABLE] == 0)
	{
		osd_stop_sample(0);
		osd_stop_sample(1);
		osd_stop_sample(2);
	}
	else if (soundchanged)
	{
		int voice;
		static int currwave[3] = { -1,-1,-1 };


		soundchanged = 0;

		for (voice = 0;voice < 3;voice++)
		{
			int freq,volume,wave;


			freq = RAM[SOUND_BASE + 0x14 + 5 * voice];	/* always 0 */
			freq = freq * 16 + RAM[SOUND_BASE + 0x13 + 5 * voice];
			freq = freq * 16 + RAM[SOUND_BASE + 0x12 + 5 * voice];
			freq = freq * 16 + RAM[SOUND_BASE + 0x11 + 5 * voice];
			if (voice == 0)
				freq = freq * 16 + RAM[SOUND_BASE + 0x10 + 5 * voice];
			else freq = freq * 16;

			freq = (SND_CLOCK / 2048) * freq / 512;
			volume = RAM[SOUND_BASE + 0x15 + 5 * voice];
			volume = (volume << 4) | volume;

			wave = RAM[SOUND_BASE + 0x05 + 5 * voice] & 7;
			if (wave != currwave[voice])
			{
				osd_play_sample(voice,samples[wave],32,freq,volume,1);
				currwave[voice] = wave;
			}
			else osd_adjust_sample(voice,freq,volume);
		}
	}

	osd_update_audio();
}
